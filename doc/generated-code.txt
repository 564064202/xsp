Generated Code
---------------

1. For standalone ASPX pages
------------------------------

1.1 Overview
-------------

The code generator, xsp, generates C# code for a System.Web.UI.Page derived
class under ASP namespace. The name of the class is either one provided by the 
@Page ClassName attribute or the default which is the aspx file name with some
mangling to make it a valid class name.

Fourteen namespaces are added always before the class. They are listed in the
file directives-syntax.txt (Import directive). The user can add more namespaces
by using that directive.

The generated class also implements IRequiresSessionState by default. The user
may choose not to implement it and/or add more interfaces via the @Implements
directive.


1.2 Private static variables
-----------------------------

The class also includes three private static variables:

	* int __autoHandlers: this one is accesed through a protected property.
	right now, i don't know what MS uses it for.

	* bool __intialized: false by default. Changed to true when the first
	instance of the class created.
	
	* ArrayList __fileDependencies: this one is filled with strings
	containing the name of the files this class depends on when the first
	instance of the class is created.


1.3 Protected instance variables
----------------------------------

There is one with the appropiated type for each control in the page. The
variable name can be a default name or the one stated in the ID attribute for
the control.


1.4 Script zone
-----------------

The code within <script runat="server> and </script> is output directly after
the variables and before the constructor.


1.4 Constructor
----------------

If __intialized == false, the constructor fills __fileDependencies.


1.5 Properties
---------------

There are always at least three properties in the generated code:

	* AutoHandlers: get/set the __autoHandlers value.

	* AplicationInstance: gets the HttpApplication from
	this.Context.ApplicationInstance.

	* TemplateSourceDirectory: this is the path of what IIS calls virtual
	directory for the application. Currently I set it to "/dummypath".

For each <object> tag it creates a read-only property with the name in the ID
attribute and a private variable of the specified CLASS, whose name is
'cachedID'. First time the property is accesed, it creates a new instance of
type CLASS, assign it to the private variable and return it.


1.6 Other functions
---------------------

* protected override void FrameworkInitialize ()

This one calls __BuildControlTree to generate the control tree, sets the
dependencies of the page to the value of __fileDependencies and turns using MAC
(machine authentication check) on. I don't know if we will use the latter (it
can be overriden by the EnableViewStateMAC attribute in @Page).

* public int GetTypeHashCode ()

Returns a random number.


1.7 The control tree
---------------------

The __BuildControlTree () function is the starting point to assign the values
to all the protected variables that are controls:

	* private void __BuildControlTree (System.Web.UI.Control __ctrl)

It gets a IParserAccessor from __ctrl (called __parser) and:

	* Calls the function that builds each control hierarchy.

	* After built, the control is added to __ctrl using
	IParserAccessor.AddParsedSubObject ().

The exceptions are LiteralControls, which are created and added directly:

__parser.AddParsedSubObject (new System.Web.UI.LiteralControl ("<html>"));

1.7.1 Building controls
------------------------

The name of the function that builds each control hierarchy is
__BuildControl${CONTROL_NAME}.

These functions:

	* Create a control of the appropiate type.

	* Assign it to the corresponding protected variable .

	* Set the Control.ID property to the name of the control (if it is not a
	default assigned one).
	
	* Depending on the tag attributes.

		o Set property values.
		o Add event handlers.
		o Set attributes using IAttributeAccessor.SetAttribute ().

	* Add contained controls to the one being built calling their build
	function first.

1.7.1.1 Properties
-------------------

Currently supported types for properties are:

	* String
	* Enumerations
	* Bool
	* System.Web.UI.WebControls.Unit
	* System.Web.UI.WebControls.FontUnit
	* Signed and unsigned integers: 16, 32, 64 bits.
	* Float and Double.
	* Color


1.7.1.2 Style, ITemplate and Columns
--------------------------------------

Style tags inside controls get their own function to set them up. In this case,
only property values are used.

ITemplate also have their own function which is almost the same as a control,
but the value of the template property is set like this:

__ctrl.ItemTemplate = new System.Web.UI.CompiledTemplateBuilder 
(new System.Web.UI.BuildTemplateMethod (this.__BuildControl__control3));

Columns property in DataGrid also gets its own build function which only allow
DataGridColumn and its derived classes to be added.


1.7.1.3 Support for data binding syntax
------------------------------------------

Data binding in literals
--------------------------

When <%# ... %> tags are supplied inside a literal control, they make xsp to
generate a couple of functions:

	* __BuildControl_{DEFAULT_ID}: creates a DataBoundLiteralControl and
	adds __DataBind_{DEFAULT_ID} as an EventHandler for DataBound Event.

	* __DataBind_{DEFAULT_ID}: sets the value of the DataBoundLiteralControl
	to the value between the tags converted to a string.


Data binding inside attributes
--------------------------------

In this case, only one more function is created __DataBind_{CONTROL_ID} in which
the data bound values are set to the value between the tags converted to a
string.


1.7.1.4 Support for code render blocks
------------------------------------------

Code render blocks (ie, C# code directly inserted in literal controls) have this
effects when used:

	* All literal controls are removed from the corresponding 
	__BuildControl function.

	* A new function
	__Render_* (HtmlTextWriter __output, Control parameterContainer), is
	created.

	* Addition of a new render method delegate for the container control
	using SetRenderMethodDelegate with the new render function created.

In this case, the __Render_* function must render the control and its contained
controls 'by hand'.

For literal controls (removed from the __BuildControl function), it generates
__output.Write (...) calls, the same as for <%= varname %> code render tags.

For <% ..code.. %> tags, it outputs the code directly.

For each control in parameterContainer.Controls, it inserts in the proper place
a call to Control.RenderControl (__output).


